# Plan: Video Export Acceleration & Direct Region Recording

## Overview

Two optimizations for the video editor:
1. **VideoToolbox Hardware Acceleration** - Use Apple's hardware encoder for 3-5x faster exports
2. **FFmpeg Region Recording** - Record only the cropped region instead of full screen + post-process

---

## Task 1: VideoToolbox Hardware Acceleration

### Current State
- All encoding uses `libx264` (CPU-based software encoder)
- Settings: `preset medium`, `crf 18` (high quality)
- Encoding locations:
  - `cutter.py:133-135` - Segment extraction with frame freeze
  - `cutter.py:161-164` - Segment extraction without frame freeze
  - `cutter.py:228-229` - Gap segment creation
  - `captioner.py` - Caption burning (4 locations)

### Implementation

#### 1. Create encoder utility module
**New file: `video_editor/encoder.py`**

```python
"""Video encoder configuration with hardware acceleration support."""
import subprocess
from dataclasses import dataclass

@dataclass
class EncoderConfig:
    use_hardware: bool = True
    quality: int = 70  # VideoToolbox quality (0-100, ~70 matches CRF 18)
    crf: int = 18  # libx264 fallback
    preset: str = "medium"

def is_videotoolbox_available() -> bool:
    """Check if h264_videotoolbox encoder is available."""
    try:
        result = subprocess.run(
            ["ffmpeg", "-hide_banner", "-encoders"],
            capture_output=True, text=True
        )
        return "h264_videotoolbox" in result.stdout
    except Exception:
        return False

def get_encoder_args(config: EncoderConfig = None) -> list[str]:
    """Get FFmpeg encoder arguments with automatic fallback."""
    config = config or EncoderConfig()

    if config.use_hardware and is_videotoolbox_available():
        return [
            "-c:v", "h264_videotoolbox",
            "-q:v", str(config.quality),
            "-profile:v", "high",
            "-allow_sw", "true",  # Fallback to software if hardware fails
        ]
    else:
        return [
            "-c:v", "libx264",
            "-preset", config.preset,
            "-crf", str(config.crf),
        ]
```

#### 2. Modify cutter.py
**File: `video_editor/cutter.py`**

Replace hardcoded encoder args at lines 133-135, 161-164, 228-229:

```python
# Import at top
from .encoder import get_encoder_args, EncoderConfig

# In __init__
def __init__(self, config: Config, encoder_config: EncoderConfig = None):
    self.config = config
    self.encoder_config = encoder_config or EncoderConfig()

# Replace in cut_segment (line 127-141):
encoder_args = get_encoder_args(self.encoder_config)
cmd = [
    "ffmpeg", "-y",
    "-i", str(input_path),
    "-vf", video_filter,
    "-af", audio_filter,
    *encoder_args,  # Dynamic encoder selection
    "-c:a", "aac",
    "-b:a", "256k",
    ...
]
```

#### 3. Modify captioner.py
Same pattern - replace `libx264` encoder args with `get_encoder_args()` call.

#### 4. Add config option
**File: `video_editor/config.py`**

```python
use_hardware_encoding: bool = True  # Use VideoToolbox if available
```

### Quality/Speed Tradeoff

| Encoder | Speed | Quality (VMAF) | File Size |
|---------|-------|----------------|-----------|
| libx264 CRF 18 | 1x (baseline) | ~95 | baseline |
| VideoToolbox q70 | 3-5x faster | ~93-95 | ~10-15% larger |

---

## Task 2: FFmpeg Direct Region Recording

### Current State
- Uses Qt's `QScreenCapture` which only captures full screens
- Post-processes with FFmpeg crop filter in `recorder_tab.py:345-388`
- Flow: Full screen capture → Save MP4 → FFmpeg crop → Final MP4 (slow, 2x disk writes)

### Limitation Discovery
**Important**: FFmpeg's `avfoundation` also cannot capture arbitrary screen regions directly. The `-video_size` parameter sets output resolution, not capture region.

**However**, we can apply the crop filter **during** recording instead of **after**, which:
- Reduces file size immediately (no full-screen intermediate file)
- Encodes smaller frames (faster)
- Uses hardware encoding for the crop+encode step

### Implementation

#### 1. Create FFmpeg recorder class
**New file: `video_editor/gui/recorder/ffmpeg_recorder.py`**

```python
"""FFmpeg-based screen recording with real-time crop."""
import subprocess
import time
from pathlib import Path
from PySide6.QtCore import QObject, Signal, QTimer

class FFmpegRecorder(QObject):
    recording_started = Signal()
    recording_stopped = Signal(Path)  # No needs_crop flag - already cropped
    recording_error = Signal(str)
    duration_changed = Signal(float)

    def __init__(self, parent=None):
        super().__init__(parent)
        self._process = None
        self._start_time = 0

    def start_recording(self, screen_index: int, crop_rect: tuple,
                        audio_device_index: int, output_path: Path,
                        use_hardware: bool = True) -> bool:
        """Start recording with crop applied during encoding."""
        crop_x, crop_y, crop_w, crop_h = crop_rect

        # Encoder selection
        if use_hardware:
            encoder_args = ["-c:v", "h264_videotoolbox", "-q:v", "70"]
        else:
            encoder_args = ["-c:v", "libx264", "-preset", "fast", "-crf", "20"]

        cmd = [
            "ffmpeg", "-y",
            "-f", "avfoundation",
            "-framerate", "30",
            "-capture_cursor", "1",
            "-i", f"{screen_index}:{audio_device_index}",
            "-vf", f"crop={crop_w}:{crop_h}:{crop_x}:{crop_y}",
            *encoder_args,
            "-c:a", "aac", "-b:a", "256k",
            str(output_path),
        ]

        self._process = subprocess.Popen(
            cmd, stdin=subprocess.PIPE,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        self._start_time = time.time()
        self.recording_started.emit()
        return True

    def stop_recording(self):
        """Stop recording gracefully."""
        if self._process:
            self._process.stdin.write(b'q')
            self._process.stdin.flush()
            self._process.wait(timeout=5)
```

#### 2. Modify RecordingController
**File: `video_editor/gui/recorder/recording_controller.py`**

Add FFmpeg recorder as alternative to Qt recorder:

```python
# Add property
self._use_ffmpeg_recording = True  # New option

def start_recording(self) -> bool:
    if self._use_ffmpeg_recording and not self._config.capture_full_screen:
        # Use FFmpeg for cropped recording
        return self._start_ffmpeg_recording()
    else:
        # Use Qt for full-screen recording (existing code)
        return self._start_qt_recording()

def _start_ffmpeg_recording(self) -> bool:
    """Start recording with FFmpeg (crop applied during capture)."""
    screen = QGuiApplication.screens()[self._config.screen_index]
    geo = screen.geometry()

    crop_rect = self._config.get_crop_rect(geo.width(), geo.height(), margin=0)
    audio_idx = self._get_ffmpeg_audio_device_index()
    output_path = self._get_output_path()

    return self._ffmpeg_recorder.start_recording(
        self._config.screen_index, crop_rect, audio_idx, output_path
    )
```

#### 3. Update recorder_tab.py
**File: `video_editor/gui/recorder/recorder_tab.py`**

Modify `_on_recording_stopped` to skip post-processing when FFmpeg was used:

```python
def _on_recording_stopped(self, output_path: Path, needs_crop: bool):
    if needs_crop:
        self._process_crop(output_path)  # Qt recording path
    else:
        self._show_completion_dialog(output_path)  # FFmpeg path (already cropped)
```

#### 4. Add settings toggle
**File: `video_editor/gui/recorder/recording_settings.py`**

```python
self._use_ffmpeg_check = QCheckBox("Use FFmpeg recording (faster crop)")
self._use_ffmpeg_check.setToolTip(
    "Apply crop during recording instead of post-processing. "
    "Faster and uses less disk space."
)
```

### Recording Flow Comparison

**Current (Qt + Post-process):**
```
Full screen → Qt H.264 → temp.mp4 (large) → FFmpeg crop → final.mp4
```

**Proposed (FFmpeg direct):**
```
Full screen → FFmpeg crop filter → VideoToolbox H.264 → final.mp4
```

Benefits:
- No intermediate full-screen file
- Hardware encoding for cropped output
- Single encoding pass

---

## Files to Modify

### Task 1: VideoToolbox
| File | Changes |
|------|---------|
| `video_editor/encoder.py` | **NEW** - Encoder utility module |
| `video_editor/cutter.py` | Replace libx264 args (3 locations) |
| `video_editor/captioner.py` | Replace libx264 args (4 locations) |
| `video_editor/config.py` | Add `use_hardware_encoding` option |

### Task 2: Region Recording
| File | Changes |
|------|---------|
| `video_editor/gui/recorder/ffmpeg_recorder.py` | **NEW** - FFmpeg recorder class |
| `video_editor/gui/recorder/recording_controller.py` | Add FFmpeg recording path |
| `video_editor/gui/recorder/recorder_tab.py` | Handle no-crop-needed case |
| `video_editor/gui/recorder/recording_settings.py` | Add toggle checkbox |

---

## Verification

### Task 1: VideoToolbox
1. Run `ffmpeg -encoders | grep videotoolbox` to confirm availability
2. Export a video with captions and compare:
   - Encoding time (expect 3-5x speedup)
   - Visual quality (should be nearly identical)
   - File size (may be ~10-15% larger)

### Task 2: Region Recording
1. Select a crop preset (e.g., 1920x1080)
2. Start recording
3. Verify output file is already cropped (no post-processing dialog)
4. Check audio sync and quality
5. Compare file sizes (cropped output should be smaller than full-screen)

---

## Fallback Behavior

- **VideoToolbox unavailable**: Automatically falls back to libx264
- **FFmpeg recording fails**: Falls back to Qt recording + post-process crop
- **Both work independently**: Can enable/disable each optimization separately
